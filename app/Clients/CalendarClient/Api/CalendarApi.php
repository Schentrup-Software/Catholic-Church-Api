<?php
/**
 * CalendarApi
 * PHP version 5
 *
 * @category Class
 * @package  App\Clients\CalendarClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Liturgical Calendar API
 *
 * Roman Catholic liturgical calendar
 *
 * OpenAPI spec version: v0
 * Contact: jkb.pavlik@gmail.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace App\Clients\CalendarClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use App\Clients\CalendarClient\ApiException;
use App\Clients\CalendarClient\Configuration;
use App\Clients\CalendarClient\HeaderSelector;
use App\Clients\CalendarClient\ObjectSerializer;

/**
 * CalendarApi Class Doc Comment
 *
 * @category Class
 * @package  App\Clients\CalendarClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CalendarApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation langCalendarsCalendarGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Calendar
     */
    public function langCalendarsCalendarGet($lang, $calendar)
    {
        list($response) = $this->langCalendarsCalendarGetWithHttpInfo($lang, $calendar);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Calendar, HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarGetWithHttpInfo($lang, $calendar)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Calendar';
        $request = $this->langCalendarsCalendarGetRequest($lang, $calendar);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Calendar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarGetAsync($lang, $calendar)
    {
        return $this->langCalendarsCalendarGetAsyncWithHttpInfo($lang, $calendar)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarGetAsyncWithHttpInfo($lang, $calendar)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Calendar';
        $request = $this->langCalendarsCalendarGetRequest($lang, $calendar);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarGetRequest($lang, $calendar)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarGet'
            );
        }

        $resourcePath = '/{lang}/calendars/{calendar}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsCalendarTodayGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Day
     */
    public function langCalendarsCalendarTodayGet($lang, $calendar, $date = null)
    {
        list($response) = $this->langCalendarsCalendarTodayGetWithHttpInfo($lang, $calendar, $date);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarTodayGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Day, HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarTodayGetWithHttpInfo($lang, $calendar, $date = null)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarTodayGetRequest($lang, $calendar, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Day',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarTodayGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarTodayGetAsync($lang, $calendar, $date = null)
    {
        return $this->langCalendarsCalendarTodayGetAsyncWithHttpInfo($lang, $calendar, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarTodayGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarTodayGetAsyncWithHttpInfo($lang, $calendar, $date = null)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarTodayGetRequest($lang, $calendar, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarTodayGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarTodayGetRequest($lang, $calendar, $date = null)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarTodayGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarTodayGet'
            );
        }

        $resourcePath = '/{lang}/calendars/{calendar}/today';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($date !== null) {
            $headerParams['Date'] = ObjectSerializer::toHeaderValue($date);
        }

        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsCalendarTomorrowGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Day
     */
    public function langCalendarsCalendarTomorrowGet($lang, $calendar, $date = null)
    {
        list($response) = $this->langCalendarsCalendarTomorrowGetWithHttpInfo($lang, $calendar, $date);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarTomorrowGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Day, HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarTomorrowGetWithHttpInfo($lang, $calendar, $date = null)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarTomorrowGetRequest($lang, $calendar, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Day',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarTomorrowGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarTomorrowGetAsync($lang, $calendar, $date = null)
    {
        return $this->langCalendarsCalendarTomorrowGetAsyncWithHttpInfo($lang, $calendar, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarTomorrowGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarTomorrowGetAsyncWithHttpInfo($lang, $calendar, $date = null)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarTomorrowGetRequest($lang, $calendar, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarTomorrowGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarTomorrowGetRequest($lang, $calendar, $date = null)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarTomorrowGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarTomorrowGet'
            );
        }

        $resourcePath = '/{lang}/calendars/{calendar}/tomorrow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($date !== null) {
            $headerParams['Date'] = ObjectSerializer::toHeaderValue($date);
        }

        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsCalendarYearGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Year
     */
    public function langCalendarsCalendarYearGet($lang, $calendar, $year)
    {
        list($response) = $this->langCalendarsCalendarYearGetWithHttpInfo($lang, $calendar, $year);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarYearGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Year, HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarYearGetWithHttpInfo($lang, $calendar, $year)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Year';
        $request = $this->langCalendarsCalendarYearGetRequest($lang, $calendar, $year);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Year',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarYearGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYearGetAsync($lang, $calendar, $year)
    {
        return $this->langCalendarsCalendarYearGetAsyncWithHttpInfo($lang, $calendar, $year)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarYearGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYearGetAsyncWithHttpInfo($lang, $calendar, $year)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Year';
        $request = $this->langCalendarsCalendarYearGetRequest($lang, $calendar, $year);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarYearGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarYearGetRequest($lang, $calendar, $year)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarYearGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarYearGet'
            );
        }
        // verify the required parameter 'year' is set
        if ($year === null || (is_array($year) && count($year) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $year when calling langCalendarsCalendarYearGet'
            );
        }
        if ($year < 1970) {
            throw new \InvalidArgumentException('invalid value for "$year" when calling CalendarApi.langCalendarsCalendarYearGet, must be bigger than or equal to 1970.');
        }


        $resourcePath = '/{lang}/calendars/{calendar}/{year}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }
        // path params
        if ($year !== null) {
            $resourcePath = str_replace(
                '{' . 'year' . '}',
                ObjectSerializer::toPathValue($year),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsCalendarYearMonthDayGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month month (required)
     * @param  int $day day (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Day
     */
    public function langCalendarsCalendarYearMonthDayGet($lang, $calendar, $year, $month, $day)
    {
        list($response) = $this->langCalendarsCalendarYearMonthDayGetWithHttpInfo($lang, $calendar, $year, $month, $day);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarYearMonthDayGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     * @param  int $day (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Day, HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarYearMonthDayGetWithHttpInfo($lang, $calendar, $year, $month, $day)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarYearMonthDayGetRequest($lang, $calendar, $year, $month, $day);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Day',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarYearMonthDayGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     * @param  int $day (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYearMonthDayGetAsync($lang, $calendar, $year, $month, $day)
    {
        return $this->langCalendarsCalendarYearMonthDayGetAsyncWithHttpInfo($lang, $calendar, $year, $month, $day)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarYearMonthDayGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     * @param  int $day (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYearMonthDayGetAsyncWithHttpInfo($lang, $calendar, $year, $month, $day)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarYearMonthDayGetRequest($lang, $calendar, $year, $month, $day);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarYearMonthDayGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     * @param  int $day (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarYearMonthDayGetRequest($lang, $calendar, $year, $month, $day)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarYearMonthDayGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarYearMonthDayGet'
            );
        }
        // verify the required parameter 'year' is set
        if ($year === null || (is_array($year) && count($year) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $year when calling langCalendarsCalendarYearMonthDayGet'
            );
        }
        if ($year < 1970) {
            throw new \InvalidArgumentException('invalid value for "$year" when calling CalendarApi.langCalendarsCalendarYearMonthDayGet, must be bigger than or equal to 1970.');
        }

        // verify the required parameter 'month' is set
        if ($month === null || (is_array($month) && count($month) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $month when calling langCalendarsCalendarYearMonthDayGet'
            );
        }
        if ($month > 12) {
            throw new \InvalidArgumentException('invalid value for "$month" when calling CalendarApi.langCalendarsCalendarYearMonthDayGet, must be smaller than or equal to 12.');
        }
        if ($month < 1) {
            throw new \InvalidArgumentException('invalid value for "$month" when calling CalendarApi.langCalendarsCalendarYearMonthDayGet, must be bigger than or equal to 1.');
        }

        // verify the required parameter 'day' is set
        if ($day === null || (is_array($day) && count($day) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $day when calling langCalendarsCalendarYearMonthDayGet'
            );
        }
        if ($day > 31) {
            throw new \InvalidArgumentException('invalid value for "$day" when calling CalendarApi.langCalendarsCalendarYearMonthDayGet, must be smaller than or equal to 31.');
        }
        if ($day < 1) {
            throw new \InvalidArgumentException('invalid value for "$day" when calling CalendarApi.langCalendarsCalendarYearMonthDayGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/{lang}/calendars/{calendar}/{year}/{month}/{day}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }
        // path params
        if ($year !== null) {
            $resourcePath = str_replace(
                '{' . 'year' . '}',
                ObjectSerializer::toPathValue($year),
                $resourcePath
            );
        }
        // path params
        if ($month !== null) {
            $resourcePath = str_replace(
                '{' . 'month' . '}',
                ObjectSerializer::toPathValue($month),
                $resourcePath
            );
        }
        // path params
        if ($day !== null) {
            $resourcePath = str_replace(
                '{' . 'day' . '}',
                ObjectSerializer::toPathValue($day),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsCalendarYearMonthGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month month (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Day[]
     */
    public function langCalendarsCalendarYearMonthGet($lang, $calendar, $year, $month)
    {
        list($response) = $this->langCalendarsCalendarYearMonthGetWithHttpInfo($lang, $calendar, $year, $month);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarYearMonthGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Day[], HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarYearMonthGetWithHttpInfo($lang, $calendar, $year, $month)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day[]';
        $request = $this->langCalendarsCalendarYearMonthGetRequest($lang, $calendar, $year, $month);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Day[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarYearMonthGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYearMonthGetAsync($lang, $calendar, $year, $month)
    {
        return $this->langCalendarsCalendarYearMonthGetAsyncWithHttpInfo($lang, $calendar, $year, $month)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarYearMonthGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYearMonthGetAsyncWithHttpInfo($lang, $calendar, $year, $month)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day[]';
        $request = $this->langCalendarsCalendarYearMonthGetRequest($lang, $calendar, $year, $month);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarYearMonthGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  int $year Year must be greater than or equal to the promulgation year of the calendar system. (required)
     * @param  int $month (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarYearMonthGetRequest($lang, $calendar, $year, $month)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarYearMonthGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarYearMonthGet'
            );
        }
        // verify the required parameter 'year' is set
        if ($year === null || (is_array($year) && count($year) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $year when calling langCalendarsCalendarYearMonthGet'
            );
        }
        if ($year < 1970) {
            throw new \InvalidArgumentException('invalid value for "$year" when calling CalendarApi.langCalendarsCalendarYearMonthGet, must be bigger than or equal to 1970.');
        }

        // verify the required parameter 'month' is set
        if ($month === null || (is_array($month) && count($month) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $month when calling langCalendarsCalendarYearMonthGet'
            );
        }
        if ($month > 12) {
            throw new \InvalidArgumentException('invalid value for "$month" when calling CalendarApi.langCalendarsCalendarYearMonthGet, must be smaller than or equal to 12.');
        }
        if ($month < 1) {
            throw new \InvalidArgumentException('invalid value for "$month" when calling CalendarApi.langCalendarsCalendarYearMonthGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/{lang}/calendars/{calendar}/{year}/{month}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }
        // path params
        if ($year !== null) {
            $resourcePath = str_replace(
                '{' . 'year' . '}',
                ObjectSerializer::toPathValue($year),
                $resourcePath
            );
        }
        // path params
        if ($month !== null) {
            $resourcePath = str_replace(
                '{' . 'month' . '}',
                ObjectSerializer::toPathValue($month),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsCalendarYesterdayGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \App\Clients\CalendarClient\Model\Day
     */
    public function langCalendarsCalendarYesterdayGet($lang, $calendar, $date = null)
    {
        list($response) = $this->langCalendarsCalendarYesterdayGetWithHttpInfo($lang, $calendar, $date);
        return $response;
    }

    /**
     * Operation langCalendarsCalendarYesterdayGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \App\Clients\CalendarClient\Model\Day, HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsCalendarYesterdayGetWithHttpInfo($lang, $calendar, $date = null)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarYesterdayGetRequest($lang, $calendar, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Day',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsCalendarYesterdayGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYesterdayGetAsync($lang, $calendar, $date = null)
    {
        return $this->langCalendarsCalendarYesterdayGetAsyncWithHttpInfo($lang, $calendar, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsCalendarYesterdayGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsCalendarYesterdayGetAsyncWithHttpInfo($lang, $calendar, $date = null)
    {
        $returnType = '\App\Clients\CalendarClient\Model\Day';
        $request = $this->langCalendarsCalendarYesterdayGetRequest($lang, $calendar, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsCalendarYesterdayGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     * @param  string $calendar Identifier of the calendar to query. (required)
     * @param  \DateTime $date Local date and time at which the message was originated, in RFC 1123 date format. If provided, the API server respects it and returns data relative to the client&#39;s today, specified in the header, instead of relative to it&#39;s own local today (which is default behaviour). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsCalendarYesterdayGetRequest($lang, $calendar, $date = null)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsCalendarYesterdayGet'
            );
        }
        // verify the required parameter 'calendar' is set
        if ($calendar === null || (is_array($calendar) && count($calendar) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $calendar when calling langCalendarsCalendarYesterdayGet'
            );
        }

        $resourcePath = '/{lang}/calendars/{calendar}/yesterday';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($date !== null) {
            $headerParams['Date'] = ObjectSerializer::toHeaderValue($date);
        }

        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($calendar !== null) {
            $resourcePath = str_replace(
                '{' . 'calendar' . '}',
                ObjectSerializer::toPathValue($calendar),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation langCalendarsGet
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function langCalendarsGet($lang)
    {
        list($response) = $this->langCalendarsGetWithHttpInfo($lang);
        return $response;
    }

    /**
     * Operation langCalendarsGetWithHttpInfo
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     *
     * @throws \App\Clients\CalendarClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function langCalendarsGetWithHttpInfo($lang)
    {
        $returnType = 'string[]';
        $request = $this->langCalendarsGetRequest($lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\App\Clients\CalendarClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation langCalendarsGetAsync
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsGetAsync($lang)
    {
        return $this->langCalendarsGetAsyncWithHttpInfo($lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation langCalendarsGetAsyncWithHttpInfo
     *
     *
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function langCalendarsGetAsyncWithHttpInfo($lang)
    {
        $returnType = 'string[]';
        $request = $this->langCalendarsGetRequest($lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'langCalendarsGet'
     *
     * @param  string $lang Specifies language used for titles of temporale feasts, Sundays and ferials, as well as other localized strings (mentioned as such in this documentation). Please note that while titles of sanctorale feasts are taken from the calendar, titles of abovementioned temporale celebrations are determined by the locale. So you have to choose a correct combination of locale and calendar in order to retrieve coherent data in one language. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function langCalendarsGetRequest($lang)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling langCalendarsGet'
            );
        }

        $resourcePath = '/{lang}/calendars';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
